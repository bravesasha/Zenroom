# Key generation

On this page we prioritize security over easy of use, therefore we have chosen to keep some operations separated.

Particularly the generation of private and public key (and the creation and signature of transactions, further down), which can indeed be merged into one script, but you would end up with both the keys in the same output.

## Private key
The script below generates a **ethereum** private key.

Note: you don't need to declare your identity using the statement ***Given I am 'User1234'***, but you can still do it if it comes handy, and then use the statement ***Then print my 'keys'*** to format the output.

[](../_media/examples/zencode_cookbook/ethereum/alice_keygen.zen ':include :type=code gherkin')

The output should look like this:

[](../_media/examples/zencode_cookbook/ethereum/alice_keys.json ':include :type=code json')

You want to store this into the file
<a href="../_media/examples/zencode_cookbook/ethereum/alice_keys.json" download>keys.json</a>

### Generate a private key from a known seed

Key generation in Zenroom uses by default a pseudo-random as seed, that is internally generated. 

You can also opt to use a seed generated elsewhere, for example by using the [keypairoom](https://github.com/ledgerproject/keypairoom) library or its [npm package](https://www.npmjs.com/package/keypair-lib). Suppose you have an Ethereum private key:

[](../_media/examples/zencode_cookbook/ethereum/doc_key.json ':include :type=code json')

Then you can upload it with a script that looks like the following script:

[](../_media/examples/zencode_cookbook/ethereum/doc_key_upload.zen ':include :type=code gherkin')

## Get a private key by password
If we use [private ethereum blockchain](https://medium.com/scb-digital/running-a-private-ethereum-blockchain-using-docker-589c8e6a4fe8), then our keyring located in docker conteiner: geth-miner.

Path like that: /root/.ethereum/keystore/UTC--2024-07-16T10-09-46.525942921Z--e...1

Usually, access from the network is not possible to this file. But there is more or less [standard access](https://github.com/ethereum/go-ethereum/blob/master/cmd/clef/tutorial.md)

The following script allows you to log in using only a password and automatically receives keyrings already generated by the miner.


[](../_media/examples/zencode_cookbook/ethereum/doc_key_pass.py ':include :type=code gherkin')


## Public key

Ethereum does not use explicitly a public key, it uses it only to create an Ethereum address that represents an account. So in Zencode there are no sentences to produce the public keys, but only the address.

If, for any reason, you need the ethereum public key, then you can simply compute it by understanding that the Ethereum private key is an ECDH private key so the following script will do the trick:

[](../_media/examples/zencode_cookbook/ethereum/doc_pubgen.zen ':include :type=code gherkin')



# Create Ethereum address


The **Ethereum address** is derived as the last 20 bytes of the public key controlling the account.
The **Ethereum address** is represented as an hexadecimal string with encoding given by [ERC-55](https://eips.ethereum.org/EIPS/eip-55). The public key is produced starting from the private key so you'll need the <a href="../_media/examples/zencode_cookbook/ethereum/alice_keys.json" download>keys.json</a> you've just generated as input to the following script: 

[](../_media/examples/zencode_cookbook/ethereum/alice_addrgen.zen ':include :type=code gherkin')

The output should look like:

[](../_media/examples/zencode_cookbook/ethereum/alice_address.json ':include :type=code json')

It is also possible to verify that a given string is a valid **Ethereum address** and also load it by running the following script:

[](../_media/examples/zencode_cookbook/ethereum/doc_checksum_enc.zen ':include :type=code gherkin')

The output should look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_checksum_enc_output.json ':include :type=code json')

# The transaction: setup and execution

The statements used to manage a transaction, follow closely the logic of the Ethereum protocol. With Ethereum we can store data on the chain or transfer eth from an address to another. What we'll do here is:

* Prepare a JSON file containing:
  * the **ethereum nonce**, it is the number of transactions sent from the sender address
  * the **gas price**
  * the **gas limit**
  * the **recipient address**
* If the transaction is used to store data then we will add to the JSON file the **data**
* Otherwise if it used to transfer eth we will add the value of the transaction which can be  expressed in wei (**wei value**), gwei (**gwei value**) or eth (**ethereum value**)
* Then we use the file above, to create a **ethereum transaction**.
* Finally we'll **sign** it using the key we generated above.

## First step: JSON file

Now prepare a JSON file containing the nonce, the gas price and the gas limit. The file should look like this:

[](../_media/examples/zencode_cookbook/ethereum/doc_tx_information.json ':include :type=code json')

## Create the transaction

### Eth transfer

Now, if you want to transfer eth, then you will need to add the recipient address and the value to be transferred in the JSON file. That will look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_tx_information_eth.json ':include :type=code json')

you can feed the above JSON to the script:

[](../_media/examples/zencode_cookbook/ethereum/doc_transaction.zen ':include :type=code gherkin')

Which will produce an unsigned transaction, formatted in human-readable JSON, that should look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_alice_to_bob_transaction.json ':include :type=code json')

### Data storage

On the other hand, if you want to store data on the chain then you will add to the JSON file a **storage contract address** and the **data** to be stored. The file should look like this:

[](../_media/examples/zencode_cookbook/ethereum/doc_tx_information_data.json ':include :type=code json')

you can feed the above JSON to the script:

[](../_media/examples/zencode_cookbook/ethereum/doc_transaction_storage.zen ':include :type=code gherkin')


Which will produce an unsigned transaction, formatted in human-readable JSON, that should look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_alice_storage_tx.json ':include :type=code json')

The data stored in this case was a **string** because ethereum allows only array of bytes as data and the string is the simplest example of that. However you can upload the type of data that you want (array or dictionaries) and then use [mpack](https://dev.zenroom.org/#/pages/zencode-cookbook-when) to serialize it before uploading it in the ethereum transaction.


## Sign the transaction

You can now pass the **transaction** produced from the above script (here we are using the transaction created to store the data), along with <a href="../_media/examples/zencode_cookbook/ethereum/alice_keys.json" download>keys.json</a> to the following script that will sign the transaction for a specific chain with **chain id** specified in the statement and produce the raw transaction. Here, for example, we are using fabt as **chain id** (https://github.com/dyne/fabchain).

[](../_media/examples/zencode_cookbook/ethereum/doc_sign_transaction.zen ':include :type=code gherkin')

The signed raw transaction should look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_signed_tx.json ':include :type=code json')

**Note: this script and the previous one can be merged** into one script that creates the transaction, signs it and prints it out.

Moreover, if you want to sign the transaction for the local testnet you can use the following script:

[](../_media/examples/zencode_cookbook/ethereum/doc_sign_transaction_local.zen ':include :type=code gherkin')

that use 1337 as default chain id.

## Broadcast and read ethereum transactions

Once you have created your signed ethereum transaction then you can use [RESTroom-mw](https://dev.zenroom.org/#/pages/restroom-mw) to connect to a node and broadcast your transaction in the Ethereum chain you have chosen. Obviously you have to have some Eth in your address to broadcast the transaction, if you want to do some test you can use the [fabchain](https://github.com/dyne/fabchain) test network, where you can claim 1 eth per day inserting your ethereum address [here](http://test.fabchain.net:5000/).

Now that you have broadcasted your transaction you can use also RESTroom-mw to retrieve the data stored in the transaction, but the data you will get will be of the form:

[](../_media/examples/zencode_cookbook/ethereum/doc_read_stored_string.json ':include :type=code json')

and we can read the original data with the following script:

[](../_media/examples/zencode_cookbook/ethereum/doc_read_stored_string.zen ':include :type=code gherkin')

The output will be:

[](../_media/examples/zencode_cookbook/ethereum/doc_retrieved_data.json ':include :type=code json')

# The ethereum signature

A user may want to sign an object different from a transaction, and may want others to be able to verify such signature using only the ethereum address. 

**Note:** the resulting ethereum signature uses the ECDSA deterministic algorithm as specified in [RFC-6979](https://www.rfc-editor.org/rfc/rfc6979).

## Creation of the signature

Given a string of which we want to compute the signature, assuming that the user already has an ethereum private key in the keyring, the signature can be created using the following script:

[](../_media/examples/zencode_cookbook/ethereum/doc_signtest_str.zen ':include :type=code gherkin')

The output should look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_signtest_str_out.json ':include :type=code json')

**Note**: the *ethereum signature* can be encoded both as a single hexadecimal string or as a table containing three values *r*, *s*, and *v*. Zenroom can load and print ethereum signatures in both the encodings.

The following script shows how to print the tabular encoding:

[](../_media/examples/zencode_cookbook/ethereum/doc_print_ethsig.zen ':include :type=code gherkin')

The output should look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_print_ethsig_out.json ':include :type=code json')

## Verification

Given the ethereum signature of the string and the ethereum address, anyone may verify the signature using the following script:

[](../_media/examples/zencode_cookbook/ethereum/doc_verifytesteth_str.zen ':include :type=code gherkin')

When the signature is correct, the output will be:

[](../_media/examples/zencode_cookbook/ethereum/doc_verifytesteth_str_out.json ':include :type=code json')

## Multiple signatures verification

Given an array that contains pairs of ethereum address and signature and a signed message

[](../_media/examples/zencode_cookbook/ethereum/signature_array.data ':include :type=code json')

anyone may verify all the signatures using the following script:

[](../_media/examples/zencode_cookbook/ethereum/signature_array.zen ':include :type=code gherkin')

This code will fail if at least one signature is not verified, to obtain a list that associates each address to the result of the verification the following script can be used:

[](../_media/examples/zencode_cookbook/ethereum/verification_result.zen ':include :type=code gherkin')

For example with the following data, where the last signature is the copy of the third one in which the *v* parameter is set to 27 instead of 28, *i.e.* is not a valid signature:

[](../_media/examples/zencode_cookbook/ethereum/verification_result.data ':include :type=code json')

the result is

[](../_media/examples/zencode_cookbook/ethereum/verification_result.out ':include :type=code json')

## Sign complex object

It could be the case that one wants to sign an object different from a string or a transaction.
This is an example of the data which a user could sign:

[](../_media/examples/zencode_cookbook/ethereum/doc_keccak_abi.data ':include :type=code json')

Given the above data, a user can first compute the hash of the ABI encoding of the data.  
This can be achieved using the following script:

[](../_media/examples/zencode_cookbook/ethereum/doc_keccak_abi.zen ':include :type=code gherkin')

The output should look like:

[](../_media/examples/zencode_cookbook/ethereum/doc_keccak_abi_out.json ':include :type=code json')

**NOTE**: in the end one can use the same scripts as above to create and verify the signature of the obtained *hash*.

# The script used to create the material in this page

## Create the smart contract for token ERC 721 by python

To create the contract itself, you can use [OpenZeppelin Contracts Wizard](https://docs.openzeppelin.com/contracts/5.x/wizard)

You can select the token type through the bookmarks in the wizard, and select the contract features through the menu on the left.

We will get something like this code:

[](../_media/examples/zencode_cookbook/ethereum/zen721.sol ':include :type=code gherkin')

We take the source codes of the contract from the repository [openzeppelin-contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)

In the contract, we replaced relative paths @openzeppelin  with the path in the current directory. To do this, we copied the directory with contracts inside the working directory.

To deploy a contract we use a script:

[](../_media/examples/zencode_cookbook/ethereum/doc_deploy_contract_erc721.py ':include :type=code gherkin')

You will also need an environment file .env

GETH_RPC_URL=http://example.com:8545
# The ID of Ethereum Network
NETWORK_ID=1337
# The password to create and access the primary account
ACCOUNT_PASSWORD=My_pass

To deploy contract for ERC721 token, you can also use the sample [deploy.sh](https://github.com/dyne/Zenroom/blob/master/test/ethereum/deploy.sh)

Also pay attention to the following examples:
[create_erc721.sh](https://github.com/dyne/Zenroom/blob/master/test/ethereum/create_erc721.sh)
[approve_erc721.sh](https://github.com/dyne/Zenroom/blob/master/test/ethereum/approve_erc721.sh)
[transfer_erc721.sh](https://github.com/dyne/Zenroom/blob/master/test/ethereum/transfer_erc721.sh)

If you select the Ownable feature in the OpenZeppelin Contracts Wizard, then in the contract constructor you need to pass the token owner's address in string format.

# Submit the transaction that deploys the contract
transaction = Zen721.constructor(my_address).build_transaction(....




All the smart contracts and the data you see in this page are generated by the scripts [ethereum.bats](https://github.com/dyne/Zenroom/blob/master/test/zencode/ethereum.bats) . If you want to run the scripts (on Linux) you should: 
 - *git clone https://github.com/dyne/Zenroom.git*
 - install  **jq**
 - download a [zenroom binary](https://zenroom.org/#downloads) and place it */bin* or */usr/bin* or in *./Zenroom/src*
